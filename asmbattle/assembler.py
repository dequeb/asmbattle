# /usr/bin/python3
# -*- coding: UTF-8 -*-
"""simple assembler code"""
import re
from enum import Enum

from .opcodes import OpCodes


class ValueTypes(Enum):
    REG_ADDRESS = "regaddress"
    ADDRESS = "address"
    REGISTER = "register"
    NUMBER = "number"
    NUMBERS = "numbers"
    UNDEFINED = "*** undefined ***"


class Assembler:
    # MATCHES: "(+|-)INTEGER"
    regex_num_str = "^[-+]?[0-9]+$"
    # MATCHES: "(.L)abel"
    regex_label_str = "^[.A-Za-z]\w*$"

    # registry value range
    MIN_VALUE = 0
    MAX_VALUE = 255

    # Regex group indexes for operands
    OP1_GROUP = 3
    OP2_GROUP = 7

    def __init__(self):
        self.regex_num = re.compile(Assembler.regex_num_str)
        self.regex_label = re.compile(Assembler.regex_label_str)

        # Contains the program code & data generated by the assembler
        self._code = []
        # Contains the mapping from instructions to assembler line
        self._mapping = {}
        # Hash map of label used to replace the labels after the assembler generated the code
        self._labels = {}
        # Hash of uppercase labels used to detect duplicates
        self._normalized_labels = {}
        # current line being assembled
        self._line = ""
        # current line number
        self._line_number = 0

    def assemble(self, text: str):
        # Use https://www.debuggex.com/
        # Matches: "label: INSTRUCTION (["')OPERAND1(]"'), (["')OPERAND2(]"')
        # GROUPS:      1       2               3                    7
        regex_line_str = "^[\t ]*(?:([.A-Za-z]\w*)[:])?(?:[\t ]*([A-Za-z]{2,4})(?:[\t ]+(\[(\w+[\t ]*((\+|-)[\t ]*\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+[\t ]*((\+|-)[\t ]*\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*))?)?)?[\t ]*([;].*)?$"
        regex_line = re.compile(regex_line_str)

        # Contains the program code & data generated by the assembler
        self._code = []
        # Contains the mapping from instructions to assembler line
        self._mapping = {}
        # Hash map of label used to replace the labels after the assembler generated the code
        self._labels = {}
        # Hash of uppercase labels used to detect duplicates
        self._normalized_labels = {}
        # current line being assembled
        self._line = ""
        # current line number
        self._line_number = 0

        # Split text into code lines
        lines = text.split('\n')

        for self._line_number in range(len(lines)):
            self._line = lines[self._line_number].replace("\t", " ")
            match = regex_line.fullmatch(self._line)
            if match is None:
                # Check if line starts with a comment otherwise the line contains an error and can not be parsed
                self._line = self._line.lstrip()
                if len(self._line) == 0 or self._line[0] != ";":
                    raise ValueError(f'syntax error in "{self._line}" on line {self._line_number}')
            else:
                if match.group(1) is not None or match.group(2) is not None:
                    if match.group(1) is not None:
                        self._add_label(match.group(1))
                    if match.group(2) is not None:
                        instr = match.group(2).upper()

                        # Add mapping instr pos to line number
                        # Don't do it for DB as this is not a real instruction
                        if instr != 'DB':
                            self._mapping[len(self._code)] = self._line_number

                        # switch case on operand name if exist
                        function_name = getattr(self, f"_oper_{instr}", None )
                        if function_name is not None:
                            getattr(self, f"_oper_{instr}") (match)
                        else:
                            self._oper_ERROR(match)

        # Replace label
        for i in range(len(self._code)):
            if type(self._code[i]) is not int:
                if self._code[i] in self._labels:
                    self._code[i] = self._labels[self._code[i]]
                else:
                    raise IndexError(f"Undefined label: {self._code[i]}")

        return {"code": self._code,
                "mapping": self._mapping,
                "labels": self._labels}

    def _parse_number(self, text: str) -> int:
        """Allowed formats: 200, 200d, 0xA4, 0o48, 101b"""

        if text[:2] == "0x":
            return int(text[2:], 16)
        elif text[:2] == "0o":
            return int(text[2:], 8)
        elif text[-1:] == "b":
            return int(text[:len(text) - 1], 2)
        elif text[-1:] == "d":
            return int(text[:len(text) - 1], 10)
        elif self.regex_num.match(text):
            return int(text, 10)
        else:
            raise ValueError(f"invalid literal for int() with base 10: {text}"
                             f" on line {self._line_number}: '{self._line}'")

    def _parse_register(self, text: str) -> int:
        """Convert register name to numeric value
        :param self:
        :param text: Allowed registers: A, B, C, D, SP
        :return: register value
        :raise: ValueError if register not found
            """
        """"""

        registers = ["A", "B", "C", "D", "SP"]
        return registers.index(text.upper())

    def _parse_offset_addressing(self, text: str) -> int:
        """ register [+ | - value]

        :param text:
        :return:
        """
        text = text.replace(" ", "")
        try:
            base = self._parse_register(text[:1])
            offset_start = 1
        except ValueError:
            base = self._parse_register(text[:2])
            offset_start = 2

        if text[offset_start] == '-':
            m = -1
        elif text[offset_start] == '+':
            m = 1
        else:
            raise ValueError(f"invalid value: {text} on line {self._line_number}: '{self._line}'")

        offset = m * self._parse_number(text[offset_start + 1:])

        if offset < -16 or offset > 15:
            raise IndexError(f"offset must be a value between -16...+15 on line {self._line_number}: '{self._line}'")

        if offset < 0:
            offset = 32 + offset   # two's complement representation in 5-bit
        return offset * 8 + base   # shift offset 3 bits right and add code for register

    def _parse_reg_or_number(self, text, type_reg, type_number):
        """Allowed: Register, Label or Number; SP+/-Number is allowed for 'regaddress' type

        :param type_reg:
        :param type_number:
        :return:
        """

        try:
            register = self._parse_register(text)
            return {type_reg: register}
        except ValueError:
            # not a register
            pass

        try:
            label = self._parse_label(text)
            return {type_number: label}
        except ValueError:
            # not a label
            pass

        if type_reg == ValueTypes.REG_ADDRESS:
            try:
                register = self._parse_offset_addressing(text)
                return {type_reg: register}
            except ValueError:
                # not an offset adressing
                pass

        # ValueError exception not catched if raised
        value = self._parse_number(text)

        if value < Assembler.MIN_VALUE or value > Assembler.MAX_VALUE:
            raise ValueError(f"{type_number} must have a value between {Assembler.MIN_VALUE}-{Assembler.MAX_VALUE} on"
                             f" line {self._line_number}: '{self._line}'")
        return {type_number: value}

    def _parse_label(self, text: str):
        match = self.regex_label.match(text)
        if match:
            return match.group()
        else:
            raise ValueError(f"{text} is not a label on line {self._line_number}: '{self._line}'")

    def _get_value(self, text):
        character = text[0]
        if character == '[':
            address = text[1:-1]
            return self._parse_reg_or_number(address, ValueTypes.REG_ADDRESS, ValueTypes.ADDRESS)
        elif character == '"':   # "String"
            text = text[1:-1]
            chars = []

            for i in range(len(text)):
                value = ord(text[i])
                if value > Assembler.MAX_VALUE:
                    raise ValueError(f"{text[i]} does not have a valid ASCII value: {value}"
                                     f" on line {self._line_number}: '{self._line}'")
                chars.append(value)
            return {ValueTypes.NUMBERS: chars}

        elif character == "'":   # single character
            text = text[1:-1]
            if len(text) > 1:
                raise ValueError(f"Only one character is allowed. Use String instead"
                                 f" on line {self._line_number}: '{self._line}'")

            value = ord(text[0])
            if value > Assembler.MAX_VALUE:
                raise ValueError(f"{text[0]} does not have a valid ASCII value: {value}"
                                 f" on line {self._line_number}: '{self._line}'")
            return {ValueTypes.NUMBER: value}

        else:   # REGISTER, NUMBER or LABEL
            return self._parse_reg_or_number(text, ValueTypes.REGISTER, ValueTypes.NUMBER)

    def _add_label(self, label: str):
        upper_label = label.upper()
        if upper_label in self._normalized_labels:
            raise KeyError(f"Duplicate label: {label}")

        if upper_label == "A" or upper_label == "B" or upper_label == "C" or upper_label == "D":
            raise ValueError(f"Label contains keyword: {upper_label} on line {self._line_number}: '{self._line}'")

        self._labels[label] = len(self._code)
        self._normalized_labels[upper_label] = len(self._code)

    def _check_no_extra_arg(self, instr, arg):
        if arg is not None:
            raise ValueError(f"{instr}: too many arguments on line {self._line_number}: '{self._line}'")

    def _oper_DB(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        if p1_type == ValueTypes.NUMBER:
            self._code.append(p1_value)
        elif (p1_type == ValueTypes.NUMBERS):
            for val in p1_value:
                self._code.append(val)
        else:
            raise ValueError(f"DB does not support operand {p1_value} on line {self._line_number}: '{self._line}'")

    def _oper_HLT(self, match: re.Match):
        try:
            p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        except TypeError:
            p1 = None

        self._check_no_extra_arg("HLT", p1)
        op_code = OpCodes.NONE
        self._code.append(op_code.value)

    def _oper_MOV(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.MOV_REG_TO_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.MOV_ADDRESS_TO_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.MOV_REGADDRESS_TO_REG
        elif p1_type == ValueTypes.ADDRESS and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.MOV_REG_TO_ADDRESS
        elif p1_type == ValueTypes.REG_ADDRESS and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.MOV_REG_TO_REGADDRESS
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.MOV_NUMBER_TO_REG
        elif p1_type == ValueTypes.ADDRESS and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.MOV_NUMBER_TO_ADDRESS
        elif p1_type == ValueTypes.REG_ADDRESS and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.MOV_NUMBER_TO_REGADDRESS
        else:
            raise ValueError(f"MOV does not support operands from {p1_type.name} to {p2_type.name}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_ADD(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.ADD_REG_TO_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.ADD_ADDRESS_TO_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.ADD_REGADDRESS_TO_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.ADD_NUMBER_TO_REG
        else:
            raise ValueError(f"ADD does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)


    def _oper_SUB(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.SUB_REG_FROM_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.SUB_ADDRESS_FROM_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.SUB_REGADDRESS_FROM_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.SUB_NUMBER_FROM_REG
        else:
            raise ValueError(f"ADD does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_INC(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("INC", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.INC_REG
        else:
            raise ValueError(f"INC does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_DEC(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("INC", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.DEC_REG
        else:
            raise ValueError(f"DEC does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_CMP(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.CMP_REG_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.CMP_ADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.CMP_REGADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.CMP_NUMBER_WITH_REG
        else:
            raise ValueError(f"CMP does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_JMP(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JMP", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JMP_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
                op_code = OpCodes.JMP_ADDRESS
        else:
            raise ValueError(f"JMP does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_JC(self, match: re.Match):
        return self._oper_JNAE(match)

    def _oper_JB(self, match: re.Match):
        return self._oper_JNAE(match)

    def _oper_JNAE(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JC", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JC_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
                op_code = OpCodes.JC_ADDRESS
        else:
            raise ValueError(f"JC does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_JNC(self, match: re.Match):
        return self._oper_JAE(match)

    def _oper_JNB(self, match: re.Match):
        return self._oper_JAE(match)

    def _oper_JAE(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JNC", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JNC_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
                op_code = OpCodes.JNC_ADDRESS
        else:
            raise ValueError(f"JNC does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_JZ(self, match: re.Match):
        return self._oper_JE(match)

    def _oper_JE(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JZ", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JZ_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
                op_code = OpCodes.JZ_ADDRESS
        else:
            raise ValueError(f"JZ does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_JNZ(self, match: re.Match):
        return self._oper_JNE(match)

    def _oper_JNE(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JNZ", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JNZ_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
                op_code = OpCodes.JNZ_ADDRESS
        else:
            raise ValueError(f"JNZ does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_JA(self, match: re.Match):
        return self._oper_JNBE(match)

    def _oper_JNBE(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JA", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JA_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
                op_code = OpCodes.JA_ADDRESS
        else:
            raise ValueError(f"JA does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_JNA(self, match: re.Match):
        return self._oper_JBE(match)

    def _oper_JBE(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("JNA", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.JNA_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
            op_code = OpCodes.JNA_ADDRESS
        else:
            raise ValueError(f"JNA does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_PUSH(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("PUSH", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.PUSH_REG
        elif p1_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.PUSH_REGADDRESS
        elif p1_type == ValueTypes.ADDRESS:
            op_code = OpCodes.PUSH_ADDRESS
        elif p1_type == ValueTypes.NUMBER:
            op_code = OpCodes.PUSH_NUMBER
        else:
            raise ValueError(f"PUSH does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_POP(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("POP", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.POP_REG
        else:
            raise ValueError(f"POP does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_CALL(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("CALL", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.CALL_REGADDRESS
        elif p1_type == ValueTypes.NUMBER:
            op_code = OpCodes.CALL_ADDRESS
        else:
            raise ValueError(f"PUSH does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_RET(self, match: re.Match):
        try:
            p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        except TypeError:
            p1 = None

        self._check_no_extra_arg("RET", p1)
        op_code = OpCodes.RET
        self._code.append(op_code.value)

    def _oper_MUL(self, match: re.Match):
        """Multiply A with operand"""
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("MUL", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.MUL_REG
        elif p1_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.MUL_REGADDRESS
        elif p1_type == ValueTypes.ADDRESS:
            op_code = OpCodes.MUL_ADDRESS
        elif p1_type == ValueTypes.NUMBER:
            op_code = OpCodes.MUL_NUMBER
        else:
            raise ValueError(f"MUL does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_DIV(self, match: re.Match):
        """Divide A by operand"""
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("DIV", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.DIV_REG
        elif p1_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.DIV_REGADDRESS
        elif p1_type == ValueTypes.ADDRESS:
            op_code = OpCodes.DIV_ADDRESS
        elif p1_type == ValueTypes.NUMBER:
            op_code = OpCodes.DIV_NUMBER
        else:
            raise ValueError(f"DIV does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_AND(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.AND_REG_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.AND_ADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.AND_REGADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.AND_NUMBER_WITH_REG
        else:
            raise ValueError(f"AND does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_OR(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.OR_REG_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.OR_ADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.OR_REGADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.OR_NUMBER_WITH_REG
        else:
            raise ValueError(f"OR does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_XOR(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.XOR_REG_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.XOR_ADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.XOR_REGADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.XOR_NUMBER_WITH_REG
        else:
            raise ValueError(f"XOR does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_NOT(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        # check if there is another parameter
        try:
            p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        except TypeError:
            p2 = None

        self._check_no_extra_arg("NOT", p2)
        if p1_type == ValueTypes.REGISTER:
            op_code = OpCodes.NOT_REG
        else:
            raise ValueError(f"NOT does not support operands {p1_value} on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)

    def _oper_SHL(self, match: re.Match):
        return self._oper_SAL(match)

    def _oper_SAL(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.SHL_REG_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.SHL_ADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.SHL_REGADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.SHL_NUMBER_WITH_REG
        else:
            raise ValueError(f"SHL does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_SHR(self, match: re.Match):
        return self._oper_SAR(match)

    def _oper_SAR(self, match: re.Match):
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.SHR_REG_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.SHR_ADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.SHR_REGADDRESS_WITH_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.NUMBER:
            op_code = OpCodes.SHR_NUMBER_WITH_REG
        else:
            raise ValueError(f"SHR does not support operands {p1_value} and {p2_value}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_IN(self, match: re.Match):
        "IO input"
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.ADDRESS:
            op_code = OpCodes.IN_PORT_TO_REG
        elif p1_type == ValueTypes.REGISTER and p2_type == ValueTypes.REG_ADDRESS:
            op_code = OpCodes.IN_REGPORT_TO_REG
        else:
            raise ValueError(f"IN does not support operands from {p1_type.name} to {p2_type.name}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_OUT(self, match: re.Match):
        "IO output"
        p1 = self._get_value(match.group(Assembler.OP1_GROUP))
        p1_type = list(p1)[0]
        p1_value = p1[p1_type]
        p2 = self._get_value(match.group(Assembler.OP2_GROUP))
        p2_type = list(p2)[0]
        p2_value = p2[p2_type]
        op_code = OpCodes.NONE

        if p1_type == ValueTypes.ADDRESS and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.OUT_REG_TO_PORT
        elif p1_type == ValueTypes.REG_ADDRESS and p2_type == ValueTypes.REGISTER:
            op_code = OpCodes.OUT_REG_TO_REGPORT
        else:
            raise ValueError(f"OUT does not support operands from {p1_type.name} to {p2_type.name}"
                             f" on line {self._line_number}: '{self._line}'")

        self._code.append(op_code.value)
        self._code.append(p1_value)
        self._code.append(p2_value)

    def _oper_ERROR(self, match: re.Match):
        raise ValueError(f"Invalid instruction"
                         f" on line {self._line_number}: '{self._line}'")


